import { planskill } from "../skills/planskill.js";
import { runDevAgent } from "./devAgent.js";
import { runDebugAgent } from "./debugAgent.js";
import { runOpsAgent } from "./opsAgent.js";
import { orchestraAgentPrompt } from "../prompts/orchestraAgentPromt.js";
import { ChatGoogleGenerativeAI } from "@langchain/google-genai";
import MessageBus from "../utils/MessageBus.js";

// Map agent roles to their runner functions
const agentMap = {
  dev: runDevAgent,
  debug: runDebugAgent,
  ops: runOpsAgent,
};

const bus = new MessageBus("orchestra");

// Use Gemini instead of Ollama
const llm = new ChatGoogleGenerativeAI({
  apiKey: process.env.GOOGLE_API_KEY,
  model: "models/gemini-2.0-flash",
  temperature: 0.1,
});

// Configuration constants
const MAX_RETRIES_PER_STEP = 2;
const STEP_TIMEOUT = 300000; // 5 minutes per step
const MAX_EXECUTION_TIME = 600000; // 10 minutes total

// Helper functions for error detection and handling
function isInfiniteLoopError(error) {
  const errorMessage = error.message || error.toString();

  // Check for common infinite loop patterns
  const loopPatterns = [
    /formatting error.*try again/i,
    /encountered a formatting error/i,
    /let me try again with the correct format/i,
    /need to follow the exact format/i,
    /semantic_code_search/i,
    /tool.*format.*error/i,
  ];

  return loopPatterns.some((pattern) => pattern.test(errorMessage));
}

function isToolFormattingError(error) {
  const errorMessage = error.message || error.toString();
  return /formatting error|format.*error|tool.*format|semantic_code_search/i.test(
    errorMessage
  );
}

// The main orchestra agent function with proper orchestration
export async function runOrchestraAgent(userTask, pubSubOptions = {}) {
  const executionId = `exec_${Date.now()}_${Math.random()
    .toString(36)
    .slice(2)}`;
  console.log(
    `[OrchestraAgent] Starting execution ${executionId} with task:`,
    userTask
  );

  try {
    // Step 1: Use planskill to decompose the task and create execution plan
    const plan = await planskill({
      user_query: userTask,
      summary_of_conversation: "",
      possible_vague_parts_of_query: [],
      difficulty_level: 50,
    });

    if (!Array.isArray(plan) || !plan.length) {
      throw new Error("No plan generated by planskill.");
    }

    console.log(
      `[OrchestraAgent] Generated plan with ${plan.length} steps:`,
      plan.map((step) => `${step.step}: ${step.subtask} (${step.agent})`)
    );

    // Step 2: Execute plan using Orchestra Agent orchestration
    const orchestraResult = await executeOrchestratedPlan(
      plan,
      userTask,
      executionId
    );

    // Step 3: Optionally publish result to message bus
    if (pubSubOptions.publishResult) {
      await bus.publish(
        pubSubOptions.publishChannel || "agent.orchestra",
        "ORCHESTRA_RESULT",
        orchestraResult
      );
    }

    console.log(
      `[OrchestraAgent] Execution ${executionId} completed successfully`
    );
    return orchestraResult;
  } catch (error) {
    console.error(`[OrchestraAgent] Execution ${executionId} failed:`, error);
    if (pubSubOptions.publishResult) {
      await bus.publish(
        pubSubOptions.publishChannel || "agent.orchestra",
        "ORCHESTRA_ERROR",
        { userTask, error: error.message || error, executionId }
      );
    }
    throw error;
  }
}

/**
 * Execute the plan using proper Orchestra Agent orchestration with improved loop control
 */
async function executeOrchestratedPlan(plan, userQuery, executionId) {
  const startTime = Date.now();
  const workflowState = {
    executionId,
    completedSteps: [],
    failedSteps: [],
    currentStepIndex: 0,
    results: [],
    conversationHistory: [],
    stepRetries: new Map(), // Track retries per step
    startTime,
    plan, // Add plan to state for reference
  };

  console.log(
    `[Orchestra] Starting orchestrated execution ${executionId} of plan with ${plan.length} steps`
  );

  // Execute steps sequentially with proper orchestration and timeout
  for (let i = 0; i < plan.length; i++) {
    // Check total execution timeout
    if (Date.now() - startTime > MAX_EXECUTION_TIME) {
      console.error(
        `[Orchestra] Execution ${executionId} timed out after ${MAX_EXECUTION_TIME}ms`
      );
      break;
    }

    const currentStep = plan[i];
    workflowState.currentStepIndex = i;

    // Check if step was already completed (prevent infinite loops)
    if (workflowState.completedSteps.includes(currentStep.step)) {
      console.log(
        `[Orchestra] Step ${currentStep.step} already completed, skipping`
      );
      continue;
    }

    const stepId = `${executionId}_step_${currentStep.step}`;
    console.log(
      `[Orchestra] Executing Step ${i + 1}/${plan.length} (ID: ${stepId}): ${
        currentStep.subtask
      }`
    );

    try {
      // Execute step with timeout and retry logic
      const stepResult = await executeStepWithRetry(
        currentStep,
        workflowState,
        userQuery,
        stepId
      );

      // Mark step as completed and store result
      if (!workflowState.completedSteps.includes(currentStep.step)) {
        workflowState.completedSteps.push(currentStep.step);
        workflowState.results.push(stepResult);
        workflowState.conversationHistory.push({
          stepId,
          step: currentStep.step,
          status: "completed",
          result: stepResult,
          timestamp: new Date().toISOString(),
        });
      }

      console.log(
        `[Orchestra] Step ${currentStep.step} completed successfully`
      );
    } catch (error) {
      console.error(`[Orchestra] Step ${i + 1} failed permanently:`, error);

      const failureInfo = {
        step: currentStep.step,
        error: error.message,
        timestamp: new Date().toISOString(),
        retryAttempts: workflowState.stepRetries.get(currentStep.step) || 0,
      };

      workflowState.failedSteps.push(failureInfo);
      workflowState.conversationHistory.push({
        stepId,
        step: currentStep.step,
        status: "failed",
        error: failureInfo,
        timestamp: new Date().toISOString(),
      });

      // Handle failure through orchestra coordination
      const shouldContinue = await handleStepFailure(
        error,
        currentStep,
        workflowState,
        plan,
        userQuery
      );

      if (!shouldContinue) {
        console.log(
          `[Orchestra] Aborting workflow ${executionId} due to critical failure`
        );
        break;
      }
    }
  }

  const executionTime = Date.now() - startTime;
  const finalStatus = determineFinalStatus(workflowState, plan);

  console.log(
    `[Orchestra] Execution ${executionId} finished in ${executionTime}ms with status: ${finalStatus}`
  );

  return {
    executionId,
    originalTask: userQuery,
    plan,
    executionSummary: {
      totalSteps: plan.length,
      completedSteps: workflowState.completedSteps.length,
      failedSteps: workflowState.failedSteps.length,
      status: finalStatus,
      executionTime,
    },
    results: workflowState.results,
    failedSteps: workflowState.failedSteps,
    conversationHistory: workflowState.conversationHistory,
  };
}

/**
 * Execute a single step with retry logic and timeout
 */
async function executeStepWithRetry(
  currentStep,
  workflowState,
  userQuery,
  stepId
) {
  const maxRetries = MAX_RETRIES_PER_STEP;
  let retryCount = workflowState.stepRetries.get(currentStep.step) || 0;
  let lastError = null;

  while (retryCount <= maxRetries) {
    try {
      console.log(
        `[Orchestra] Attempting step ${currentStep.step}, attempt ${
          retryCount + 1
        }/${maxRetries + 1}`
      );

      workflowState.stepRetries.set(currentStep.step, retryCount);

      const orchestraResponse = await Promise.race([
        coordinateStepExecution(currentStep, workflowState, userQuery),
        new Promise((_, reject) =>
          setTimeout(() => reject(new Error("Coordination timeout")), 30000)
        ),
      ]);

      const agentResult = await Promise.race([
        executeAgentTaskWithLoopDetection(currentStep, stepId, lastError),
        new Promise((_, reject) =>
          setTimeout(
            () => reject(new Error("Agent execution timeout")),
            STEP_TIMEOUT
          )
        ),
      ]);

      const processedResult = await processStepResult(
        orchestraResponse,
        agentResult,
        currentStep,
        workflowState
      );

      return processedResult;
    } catch (error) {
      lastError = error;
      retryCount++;
      workflowState.stepRetries.set(currentStep.step, retryCount);

      // Check for infinite loop patterns
      if (isInfiniteLoopError(error)) {
        console.error(
          `[Orchestra] Infinite loop detected in step ${currentStep.step}:`,
          error.message
        );
        throw new Error(`Infinite loop detected: ${error.message}`);
      }

      console.warn(
        `[Orchestra] Step ${currentStep.step} attempt ${retryCount} failed:`,
        error.message
      );

      if (retryCount > maxRetries) {
        throw new Error(
          `Step failed after ${maxRetries + 1} attempts: ${error.message}`
        );
      }

      const waitTime = Math.min(1000 * Math.pow(2, retryCount - 1), 10000);
      console.log(`[Orchestra] Waiting ${waitTime}ms before retry...`);
      await new Promise((resolve) => setTimeout(resolve, waitTime));
    }
  }
}

/**
 * Enhanced agent task execution with loop detection
 */
async function executeAgentTaskWithLoopDetection(step, stepId, lastError) {
  const runner = agentMap[step.agent];
  if (!runner) {
    throw new Error(`Unknown agent: ${step.agent}`);
  }

  console.log(
    `[Orchestra] Delegating to ${step.agent.toUpperCase()} agent (${stepId}): ${
      step.subtask
    }`
  );

  // Add context to prevent loops and provide error information
  let enhancedSubtask = `[Step ${step.step}] ${step.subtask}`;

  // If we had a previous error, add guidance to avoid it
  if (lastError && isToolFormattingError(lastError)) {
    enhancedSubtask += `\n\nIMPORTANT: Previous attempt failed due to tool formatting error. 
    Please ensure all tool calls use proper JSON format and avoid infinite retry loops.
    If a tool consistently fails, try an alternative approach or skip that tool.
    DO NOT use semantic_code_search or other tools that may cause formatting errors.`;
  }

  const result = await runner(enhancedSubtask, {
    publishResult: false,
    stepId,
    stepNumber: step.step,
    maxToolRetries: 2, // Limit tool retries
    preventInfiniteLoops: true,
  });

  return {
    stepId,
    agent: step.agent,
    subtask: step.subtask,
    result,
    timestamp: new Date().toISOString(),
  };
}

/**
 * Determine final execution status
 */
function determineFinalStatus(workflowState, plan) {
  if (workflowState.failedSteps.length === 0) {
    return "SUCCESS";
  } else if (workflowState.completedSteps.length === 0) {
    return "FAILED";
  } else if (workflowState.completedSteps.length === plan.length) {
    return "SUCCESS_WITH_RECOVERABLE_ERRORS";
  } else {
    return "PARTIAL_SUCCESS";
  }
}

/**
 * Use Orchestra Agent prompt to coordinate step execution with all required parameters
 */
async function coordinateStepExecution(currentStep, workflowState, userQuery) {
  try {
    const context = {
      step: currentStep.step,
      agent: currentStep.agent,
      subtask: currentStep.subtask,
      completedSteps: workflowState.completedSteps,
      failedSteps: workflowState.failedSteps.map((f) => f.step),
      userQuery,
    };

    console.log(
      `[Orchestra] Coordinating step ${currentStep.step} with context:`,
      context
    );

    // Prepare prompt input with all required parameters
    const promptInput = await orchestraAgentPrompt.format({
      user_task: userQuery,
      step_number: currentStep.step,
      agent_type: currentStep.agent,
      subtask: currentStep.subtask,
      completed_steps: workflowState.completedSteps.join(", ") || "None",
      failed_steps:
        workflowState.failedSteps.map((f) => f.step).join(", ") || "None",
      plan: JSON.stringify(workflowState.plan || [], null, 2), // Add the missing plan parameter
      deliverables: currentStep.deliverables || "Complete the assigned task",
      context: JSON.stringify(context, null, 2),
      error_prevention: `
        CRITICAL: If tools fail repeatedly with formatting errors, try alternative approaches.
        Avoid infinite retry loops. If a tool fails 2+ times, skip it or use a different method.
        Focus on completing the core task even if some tools are unavailable.
        DO NOT use semantic_code_search or other problematic tools.
      `,
    });

    const response = await llm.invoke(promptInput);

    console.log(
      `[Orchestra] Coordination response for step ${currentStep.step}:`,
      response
    );

    return response;
  } catch (error) {
    console.error("[Orchestra] Coordination failed:", error);
    return `Fallback coordination for step ${currentStep.step}: Execute ${currentStep.subtask} with ${currentStep.agent} agent. 
    AVOID infinite loops - if tools fail repeatedly, try alternative approaches.
    DO NOT use semantic_code_search or other problematic tools.`;
  }
}

/**
 * Execute the actual agent task with unique identification (fallback method)
 */
async function executeAgentTask(step, stepId) {
  const runner = agentMap[step.agent];
  if (!runner) {
    throw new Error(`Unknown agent: ${step.agent}`);
  }

  console.log(
    `[Orchestra] Delegating to ${step.agent.toUpperCase()} agent (${stepId}): ${
      step.subtask
    }`
  );

  // Add step context to prevent agent confusion
  const enhancedSubtask = `[Step ${step.step}] ${step.subtask}`;
  const result = await runner(enhancedSubtask, {
    publishResult: false,
    stepId,
    stepNumber: step.step,
  });

  return {
    stepId,
    agent: step.agent,
    subtask: step.subtask,
    result,
    timestamp: new Date().toISOString(),
  };
}

/**
 * Process step result through orchestra coordination
 */
async function processStepResult(
  orchestraResponse,
  agentResult,
  step,
  workflowState
) {
  const processed = {
    step: step.step,
    agent: step.agent,
    subtask: step.subtask,
    deliverables: step.deliverables,
    agentResult: agentResult.result,
    orchestraCoordination:
      orchestraResponse.content ||
      orchestraResponse.toString().substring(0, 500), // Handle response properly
    status: "SUCCESS",
    timestamp: new Date().toISOString(),
    stepId: agentResult.stepId,
  };

  console.log(`[Orchestra] Step ${step.step} processed successfully`);
  return processed;
}

/**
 * Handle step failure through orchestra coordination with improved logic
 */
async function handleStepFailure(error, step, workflowState, plan, userQuery) {
  console.log(
    `[Orchestra] Handling failure for step ${step.step}:`,
    error.message
  );

  // Special handling for infinite loop errors
  if (isInfiniteLoopError(error)) {
    console.error(
      `[Orchestra] Infinite loop detected in step ${step.step}, this is critical`
    );
    return false; // Always abort on infinite loops
  }

  // Check if we have made any progress
  const hasProgress = workflowState.completedSteps.length > 0;

  // Critical step detection
  const isCriticalStep =
    step.agent === "ops" ||
    step.subtask.toLowerCase().includes("critical") ||
    step.subtask.toLowerCase().includes("essential");

  // Check remaining steps
  const remainingSteps = plan.length - workflowState.currentStepIndex - 1;
  const failureRate =
    workflowState.failedSteps.length / (workflowState.currentStepIndex + 1);

  // Enhanced decision logic
  if (isCriticalStep && !hasProgress) {
    console.log("[Orchestra] Critical step failed with no progress, aborting");
    return false;
  }

  if (failureRate > 0.6) {
    // More than 60% failure rate
    console.log("[Orchestra] High failure rate detected, aborting");
    return false;
  }

  if (remainingSteps === 0) {
    console.log("[Orchestra] No remaining steps, completing workflow");
    return false;
  }

  // Check for repeated infinite loop errors
  const recentLoopErrors = workflowState.failedSteps
    .slice(-3)
    .filter((f) => isInfiniteLoopError(new Error(f.error)));

  if (recentLoopErrors.length >= 2) {
    console.log("[Orchestra] Multiple infinite loop errors detected, aborting");
    return false;
  }

  console.log("[Orchestra] Continuing with workflow despite failure");
  return true;
}

// Listen for orchestra tasks via pubsub and auto-process
export function subscribeToOrchestraTasks(
  orchestraAgentRunner = runOrchestraAgent
) {
  bus.subscribe("agent.orchestra.task", async (msg) => {
    const requestId = `req_${Date.now()}_${Math.random()
      .toString(36)
      .slice(2)}`;

    try {
      console.log(`[OrchestraAgent] Processing message ${requestId}:`, msg);

      const data = msg.data || msg;
      if (!data || !data.userTask) {
        console.error(
          `[OrchestraAgent] Invalid message format for ${requestId}:`,
          msg
        );
        return;
      }

      const { userTask, replyChannel } = data;
      console.log(
        `[OrchestraAgent] Received user task ${requestId}:`,
        userTask
      );

      if (!replyChannel) {
        console.error(
          `[OrchestraAgent] No reply channel provided for ${requestId}`
        );
        return;
      }

      const result = await orchestraAgentRunner(userTask);

      await bus.publish(replyChannel, "ORCHESTRA_RESULT", result);

      console.log(
        `[OrchestraAgent] Successfully published result for ${requestId}!`
      );
    } catch (err) {
      console.error(`[OrchestraAgent] Handler error for ${requestId}:`, err);
      if (msg?.data?.replyChannel) {
        try {
          await bus.publish(msg.data.replyChannel, "ORCHESTRA_ERROR", {
            error: err.message || "Unknown error occurred",
            requestId,
          });
        } catch (publishErr) {
          console.error(
            `[OrchestraAgent] Failed to publish error for ${requestId}:`,
            publishErr
          );
        }
      }
    }
  });
}
