import { planskill } from "../skills/planskill.js";
import { runDevAgent } from "./devAgent.js";
import { runDebugAgent } from "./debugAgent.js";
import { runOpsAgent } from "./opsAgent.js";
import MessageBus from "../utils/MessageBus.js";

// Map agent roles to their runner functions
const agentMap = {
  dev: runDevAgent,
  debug: runDebugAgent,
  ops: runOpsAgent,
};

const bus = new MessageBus("orchestra");

// The main orchestra agent function
export async function runOrchestraAgent(userTask, pubSubOptions = {}) {
  try {
    console.log("[OrchestraAgent] Starting with task:", userTask);

    // Step 1: Use planskill to decompose the task and assign agents
    const plan = await planskill({
      user_query: userTask,
      summary_of_conversation: "",
      possible_vague_parts_of_query: [],
      difficulty_level: 50,
    });

    if (!Array.isArray(plan) || !plan.length) {
      throw new Error("No plan generated by planskill.");
    }

    // Step 2: In parallel, delegate subtasks to respective agents
    const subtaskPromises = plan.map(async (step) => {
      const runner = agentMap[step.agent];
      if (!runner) {
        return { ...step, error: `Unknown agent: ${step.agent}` };
      }
      try {
        const result = await runner(step.subtask, { publishResult: false });
        return { ...step, result };
      } catch (err) {
        return { ...step, error: err.message || String(err) };
      }
    });

    const subtaskResults = await Promise.all(subtaskPromises);

    // Step 3: Aggregate results
    const finalOutput = {
      originalTask: userTask,
      plan,
      results: subtaskResults,
    };

    // Step 4: Optionally publish result to message bus
    if (pubSubOptions.publishResult) {
      await bus.publish(
        pubSubOptions.publishChannel || "agent.orchestra",
        "ORCHESTRA_RESULT",
        finalOutput
      );
    }

    return finalOutput;
  } catch (error) {
    console.error("[OrchestraAgent] Execution failed:", error);
    if (pubSubOptions.publishResult) {
      await bus.publish(
        pubSubOptions.publishChannel || "agent.orchestra",
        "ORCHESTRA_ERROR",
        { userTask, error: error.message || error }
      );
    }
    throw error;
  }
}

// Listen for orchestra tasks via pubsub and auto-process
export function subscribeToOrchestraTasks(
  orchestraAgentRunner = runOrchestraAgent
) {
  bus.subscribe("agent.orchestra.task", async (msg) => {
    try {
      console.log("[OrchestraAgent] Processing message:", msg);

      const data = msg.data || msg;
      if (!data || !data.userTask) {
        console.error("[OrchestraAgent] Invalid message format:", msg);
        return;
      }

      const { userTask, replyChannel } = data;
      console.log("[OrchestraAgent] Received user task:", userTask);

      if (!replyChannel) {
        console.error("[OrchestraAgent] No reply channel provided");
        return;
      }

      const result = await orchestraAgentRunner(userTask);

      await bus.publish(replyChannel, "ORCHESTRA_RESULT", result);

      console.log("[OrchestraAgent] Successfully published result!");
    } catch (err) {
      console.error("[OrchestraAgent] Handler error:", err);
      if (msg?.data?.replyChannel) {
        try {
          await bus.publish(msg.data.replyChannel, "ORCHESTRA_ERROR", {
            error: err.message || "Unknown error occurred",
          });
        } catch (publishErr) {
          console.error(
            "[OrchestraAgent] Failed to publish error:",
            publishErr
          );
        }
      }
    }
  });
}
